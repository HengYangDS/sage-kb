C:\Users\Administrator\projects\junie_mcp\.context\index.md: text/plain (text)
C:\Users\Administrator\projects\junie_mcp\.context\decisions\ADR-0001-architecture.md: text/plain (text)
C:\Users\Administrator\projects\junie_mcp\.context\intelligence\patterns.md: text/plain (text)

--- C:\Users\Administrator\projects\junie_mcp\.context\index.md contents: ---
[Reading 165 lines from start (total: 166 lines, 1 remaining)]

# Project Context Navigation

> Project-specific knowledge base for SAGE Knowledge Base

---

## Table of Contents

[1. Directory Structure](#1-directory-structure) · [2. Content Categories](#2-content-categories) · [3. Quick Access](#3-quick-access)

---

## 1. Directory Structure

| Directory         | Purpose                              | Files |
|-------------------|--------------------------------------|-------|
| `policies/`       | Project-specific policies            | 6     |
| `conventions/`    | Project-specific coding conventions  | 3     |
| `decisions/`      | Architecture Decision Records (ADRs) | 8     |
| `intelligence/`   | AI intelligence patterns             | 7     |

---

## 2. Content Categories

### 2.1 Policies

Project-specific policy documentation:

| Document                    | Description                                   |
|-----------------------------|-----------------------------------------------|
| `timeout_hierarchy.md`      | T1-T5 timeout levels and fallback strategies  |
| `loading_configurations.md` | Knowledge loading strategies and layer config |
| `runtime_settings.md`       | Environment variables, logging, services      |
| `memory_settings.md`        | Memory persistence and caching configuration  |
| `plugin_settings.md`        | Plugin system settings and extension points   |
| `service_settings.md`       | Service layer configuration (CLI, MCP, API)   |

### 2.2 Conventions

Project-specific rules and standards:

| Document            | Description                              |
|---------------------|------------------------------------------|
| `naming.md`         | Naming conventions for all code elements |
| `code_patterns.md`  | DI, EventBus, timeout, async patterns    |
| `file_structure.md` | Directory layout, module organization    |

### 2.3 Decisions

Architecture Decision Records documenting significant technical decisions:

| ADR      | Title                           | Status   |
|----------|---------------------------------|----------|
| ADR-0001 | Three-Layer Architecture        | Accepted |
| ADR-0002 | SAGE Protocol Design            | Accepted |
| ADR-0003 | Timeout Hierarchy Design        | Accepted |
| ADR-0004 | Dependency Injection Container  | Accepted |
| ADR-0005 | Event Bus Architecture          | Accepted |
| ADR-0006 | Protocol-First Interface Design | Accepted |
| ADR-0007 | Configuration Management        | Accepted |
| ADR-0008 | Plugin System Design            | Accepted |

### 2.4 Intelligence

AI collaboration patterns and learned behaviors:

| Document              | Description                                       |
|-----------------------|---------------------------------------------------|
| `patterns.md`         | Successful interaction patterns and templates     |
| `optimizations.md`    | Code generation preferences, testing, performance |
| `calibration.md`      | Autonomy level calibration (L1-L6)                |
| `cases.md`            | Case studies and real-world examples              |
| `common_pitfalls.md`  | Common mistakes and how to avoid them             |
| `lessons_learned.md`  | Key learnings from project development            |
| `performance_tuning.md` | Performance optimization strategies             |

---

## 3. Quick Access

### 3.1 By Topic

| Topic                | Documents                                                                        |
|----------------------|----------------------------------------------------------------------------------|
| **Getting Started**  | `conventions/naming.md`, `conventions/file_structure.md`                         |
| **Architecture**     | `decisions/ADR-0001-architecture.md`, `decisions/ADR-0002-sage-protocol.md`      |
| **Configuration**    | `policies/runtime_settings.md`, `policies/loading_configurations.md` |
| **Timeouts**         | `policies/timeout_hierarchy.md`, `decisions/ADR-0003-timeout-hierarchy.md` |
| **DI & Events**      | `decisions/ADR-0004-dependency-injection.md`, `decisions/ADR-0005-event-bus.md`  |
| **AI Collaboration** | `intelligence/patterns.md`, `intelligence/calibration.md`                        |

### 3.2 All Documents

#### Policies

- `policies/timeout_hierarchy.md` — SAGE T1-T5 timeout levels
- `policies/loading_configurations.md` — Loading strategies and layers
- `policies/runtime_settings.md` — Environment and runtime config
- `policies/memory_settings.md` — Memory persistence and caching
- `policies/plugin_settings.md` — Plugin system settings
- `policies/service_settings.md` — Service layer configuration

#### Conventions

- `conventions/naming.md` — Naming conventions
- `conventions/code_patterns.md` — Code patterns (DI, EventBus, etc.)
- `conventions/file_structure.md` — File and directory organization

#### Decisions (ADRs)

- `decisions/ADR-0001-architecture.md` — Three-layer architecture
- `decisions/ADR-0002-sage-protocol.md` — SAGE protocol design
- `decisions/ADR-0003-timeout-hierarchy.md` — Timeout hierarchy
- `decisions/ADR-0004-dependency-injection.md` — DI container
- `decisions/ADR-0005-event-bus.md` — Event bus
- `decisions/ADR-0006-protocol-first.md` — Protocol-first design
- `decisions/ADR-0007-configuration.md` — Configuration management
- `decisions/ADR-0008-plugin-system.md` — Plugin system

#### Intelligence

- `intelligence/patterns.md` — AI interaction patterns
- `intelligence/optimizations.md` — Project optimizations
- `intelligence/calibration.md` — Autonomy calibration
- `intelligence/cases.md` — Case studies and examples
- `intelligence/common_pitfalls.md` — Common mistakes to avoid
- `intelligence/lessons_learned.md` — Key project learnings
- `intelligence/performance_tuning.md` — Performance optimization

---

## 4. Usage Guide

### 4.1 For New Contributors

1. Start with `conventions/naming.md` and `conventions/file_structure.md`
2. Read key ADRs: ADR-0001 (architecture), ADR-0002 (SAGE protocol)
3. Review `intelligence/patterns.md` for AI collaboration

### 4.2 For AI Assistants

1. Check `intelligence/calibration.md` for autonomy levels
2. Follow patterns in `intelligence/patterns.md`
3. Use optimizations from `intelligence/optimizations.md`
4. Reference conventions when generating code

### 4.3 For Policies

1. Timeout settings: `policies/timeout_hierarchy.md`
2. Loading behavior: `policies/loading_configurations.md`
3. Runtime/environment: `policies/runtime_settings.md`

---

## Related

- `content/` — Generic, reusable knowledge
- `.junie/guidelines.md` — AI collaboration guidelines
- `docs/design/` — Design documents
- `README.md` — Project overview

---

*Part of SAGE Knowledge Base - Project Context*

--- C:\Users\Administrator\projects\junie_mcp\.context\decisions\ADR-0001-architecture.md contents: ---
[Reading 185 lines from start (total: 186 lines, 1 remaining)]

# ADR-0001: Three-Layer Architecture

> Architecture Decision Record for SAGE Knowledge Base

---

## Status

**Accepted** | Date: 2025-11-28

---

## Context

SAGE Knowledge Base needs a modular, maintainable architecture that:

1. Separates concerns clearly between infrastructure, business logic, and interfaces
2. Supports multiple service interfaces (CLI, MCP, API)
3. Enables independent testing and deployment of components
4. Allows runtime extension through capabilities
5. Maintains clean dependency direction

### Constraints

- Must keep core minimal (<500 lines)
- Must support async operations throughout
- Must enable hot-pluggable capabilities
- Must isolate development tools from production code

---

## Decision

Adopt a **Core-Services-Capabilities** three-layer architecture with dev tools isolation.

### Layer Structure

```
┌─────────────────────────────────────────────────────────┐
│                    Core Engine Layer                    │
│                   (<500 lines minimal)                  │
│  • SAGE Protocol Interface                              │
│  • TimeoutManager                                       │
│  • EventBus                                             │
│  • DI Container                                         │
└─────────────────────────────────────────────────────────┘
                           │
          ┌────────────────┼────────────────┐
          │                │                │
          ▼                ▼                ▼
┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐
│   CLI Service   │ │   MCP Service   │ │   API Service   │
│     (Typer)     │ │    (FastMCP)    │ │    (FastAPI)    │
└─────────────────┘ └─────────────────┘ └─────────────────┘
          │                │                │
          └────────────────┼────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────┐
│                  Capabilities Layer                     │
│           (Analyzers, Checkers, Monitors)               │
└─────────────────────────────────────────────────────────┘
```

### Layer Responsibilities

| Layer            | Responsibility                         | Dependencies      |
|------------------|----------------------------------------|-------------------|
| **Core**         | Infrastructure, protocols, DI, events  | None (standalone) |
| **Services**     | User interfaces (CLI, MCP, API)        | Core              |
| **Capabilities** | Runtime features (analyzers, checkers) | Core              |

### Dependency Rules

1. **Unidirectional**: Services → Core ← Capabilities
2. **No cross-layer**: Services cannot depend on Capabilities directly
3. **Protocol-based**: Layers communicate via protocols and EventBus
4. **Core isolation**: Core has zero external dependencies beyond stdlib

---

## Alternatives Considered

### Alternative 1: Monolithic Architecture

Single module with all functionality.

- **Pros**: Simple, no abstraction overhead
- **Cons**: Hard to test, maintain, extend; tight coupling
- **Rejected**: Does not scale with project growth

### Alternative 2: Hexagonal (Ports & Adapters)

Strict hexagonal architecture with ports and adapters.

- **Pros**: Very clean separation, highly testable
- **Cons**: Over-engineering for current scope; complexity overhead
- **Rejected**: Too complex for knowledge base domain

### Alternative 3: Plugin-Only Architecture

Everything as plugins, minimal core.

- **Pros**: Maximum flexibility
- **Cons**: Discovery complexity, performance overhead, harder debugging
- **Rejected**: Knowledge base needs stable core behaviors

---

## Consequences

### Positive

1. **Clear separation**: Each layer has single responsibility
2. **Testability**: Layers can be tested in isolation
3. **Flexibility**: Services and capabilities can be added independently
4. **Maintainability**: Changes localized to specific layers
5. **Scalability**: New services (e.g., gRPC) easily added

### Negative

1. **Indirection**: EventBus adds some complexity
2. **Learning curve**: New developers must understand layer boundaries
3. **Boilerplate**: Protocol definitions required for cross-layer communication

### Risks

1. **Layer leakage**: Developers might bypass layer boundaries
2. **Over-abstraction**: Risk of creating unnecessary protocols

### Mitigations

1. **Linting rules**: Enforce import restrictions
2. **Code review**: Check for layer violations
3. **Documentation**: Clear guidelines in `.context/conventions/`

---

## Implementation

### Directory Structure

```
src/sage/
├── core/           # Core layer
│   ├── config.py
│   ├── di/
│   ├── events/
│   ├── logging/
│   └── memory/
├── services/       # Services layer
│   ├── cli.py
│   ├── mcp.py
│   └── api.py
└── capabilities/   # Capabilities layer
    ├── analyzers/
    ├── checkers/
    └── monitors/
```

### Communication Patterns

```python
# Services → Core: Direct dependency
from sage.core.config import get_config
config = get_config()

# Core → Services: Via EventBus (decoupled)
bus.publish(Event(type="knowledge.loaded", data={...}))

# Services ↔ Capabilities: Via DI Container
analyzer = container.resolve(AnalyzerProtocol)
```

---

## Related

- `ADR-0004-dependency-injection.md` — DI container design
- `ADR-0005-event-bus.md` — Event communication
- `docs/design/01-architecture.md` — Full architecture documentation

---

*Part of SAGE Knowledge Base - Architecture Decisions*

--- C:\Users\Administrator\projects\junie_mcp\.context\intelligence\patterns.md contents: ---
[Reading 276 lines from start (total: 277 lines, 1 remaining)]

# AI Collaboration Patterns

> Successful interaction patterns and project-specific optimizations for SAGE Knowledge Base

---

## Table of Contents

[1. Overview](#1-overview) · [2. Interaction Patterns](#2-interaction-patterns) · [3. Knowledge Capture Patterns](#3-knowledge-capture-patterns) · [4. Optimization Strategies](#4-optimization-strategies) · [5. Calibration Data](#5-calibration-data)

---

## 1. Overview

This document captures successful AI collaboration patterns discovered during SAGE development. These patterns help
maintain consistency and efficiency in human-AI interactions.

### 1.1 Purpose

- Document proven interaction strategies
- Capture project-specific optimizations
- Track calibration data for autonomy levels
- Provide reference for future sessions

### 1.2 Pattern Categories

| Category              | Description                         |
|-----------------------|-------------------------------------|
| **Interaction**       | Communication and workflow patterns |
| **Knowledge Capture** | When and how to document knowledge  |
| **Optimization**      | Efficiency improvements             |
| **Calibration**       | Autonomy level adjustments          |

---

## 2. Interaction Patterns

### 2.1 Session Start Pattern

**Context**: Beginning a new collaboration session

**Pattern**:

1. Review `.junie/guidelines.md` for project context
2. Check `.history/current/` for active sessions
3. Review recent commits for context continuity
4. Establish task scope and autonomy level

**Benefits**: Faster context loading, consistent behavior

### 2.2 Progressive Disclosure Pattern

**Context**: Handling complex multi-step tasks

**Pattern**:

1. Start with high-level plan
2. Execute one step at a time
3. Report progress after each step
4. Adjust plan based on findings

**Benefits**: Maintains transparency, allows course correction

### 2.3 Clarification Request Pattern

**Context**: Ambiguous or incomplete requirements

**Pattern**:

1. State understanding of the requirement
2. List specific ambiguities
3. Propose default interpretation
4. Ask for confirmation or clarification

**Example**:

```
I understand you wish to update the configuration files. A few points to confirm:
1. Does this include configuration in all subdirectories? (Default: Yes)
2. Should the original files be backed up? (Default: No)
Please confirm or adjust.
```

### 2.4 Batch Operation Pattern

**Context**: Multiple similar changes across files

**Pattern**:

1. Identify all affected files first
2. Group by change type
3. Execute in batches with verification
4. Summarize changes at end

**Benefits**: Reduces errors, maintains consistency

---

## 3. Knowledge Capture Patterns

### 3.1 Decision Point Pattern

**When to capture**: Significant technical decisions made during development

**What to capture**:

- Context and constraints
- Options considered
- Decision rationale
- Expected consequences

**Where**: `.context/decisions/ADR-NNNN-*.md`

### 3.2 Convention Discovery Pattern

**When to capture**: New coding patterns or standards emerge

**What to capture**:

- Pattern description
- Usage examples
- When to apply
- Exceptions

**Where**: `.context/conventions/*.md`

### 3.3 Session Handoff Pattern

**When to capture**: End of significant work session

**What to capture**:

- Completed tasks
- Pending items
- Important findings
- Next steps

**Where**: `.history/handoffs/*.md`

### 3.4 Problem-Solution Pattern

**When to capture**: Solving non-trivial problems

**What to capture**:

- Problem description
- Investigation steps
- Root cause
- Solution applied

**Where**: Relevant documentation or `.history/conversations/`

---

## 4. Optimization Strategies

### 4.1 Context Window Optimization

**Strategy**: Minimize context while maximizing relevance

**Techniques**:

- Use targeted file searches over full directory scans
- Request specific line ranges when opening files
- Collapse completed plan items to save space
- Reference files by path instead of including content

### 4.2 Token Budget Management

**Strategy**: Stay within T4 (5s) timeout for most operations

**Techniques**:

- Load core knowledge first (highest priority)
- Use smart loading based on task type
- Implement graceful degradation for large requests
- Cache frequently accessed content

### 4.3 Parallel Task Execution

**Strategy**: Execute independent tasks concurrently

**Techniques**:

- Identify task dependencies
- Group independent operations
- Use batch commands where possible
- Verify results collectively

### 4.4 Error Recovery Strategy

**Strategy**: Graceful handling of failures

**Techniques**:

- Always have fallback approach
- Document partial progress
- Preserve work before risky operations
- Report issues with context

---

## 5. Calibration Data

### 5.1 Autonomy Level Calibration

Current calibration for SAGE project:

| Task Type             | Recommended Level | Notes                      |
|-----------------------|-------------------|----------------------------|
| Documentation updates | L5 (High)         | Well-established patterns  |
| Code formatting       | L5 (High)         | Ruff handles automatically |
| Bug fixes             | L4 (Medium-High)  | Verify with tests          |
| New features          | L3 (Medium)       | Discuss design first       |
| Architecture changes  | L2 (Low)          | Requires approval          |
| Breaking changes      | L1 (Minimal)      | Full review required       |

### 5.2 Response Time Expectations

| Operation           | Expected Time | Timeout Level |
|---------------------|---------------|---------------|
| Simple query        | < 100ms       | T1            |
| Single file read    | < 500ms       | T2            |
| Multi-file analysis | < 2s          | T3            |
| Full KB load        | < 5s          | T4            |
| Complex analysis    | < 10s         | T5            |

### 5.3 Quality Thresholds

| Metric        | Target | Action if Below        |
|---------------|--------|------------------------|
| Test coverage | > 80%  | Add tests before merge |
| Type coverage | > 90%  | Add type hints         |
| Doc coverage  | > 70%  | Add docstrings         |
| Complexity    | < 10   | Refactor function      |

---

## 6. Anti-Patterns

### 6.1 Avoid: Over-Engineering

**Problem**: Adding complexity for hypothetical future needs

**Instead**: Implement minimal solution, extend when needed

### 6.2 Avoid: Silent Assumptions

**Problem**: Proceeding without confirming ambiguous requirements

**Instead**: Use Clarification Request Pattern (2.3)

### 6.3 Avoid: Monolithic Changes

**Problem**: Large changes that are hard to review/revert

**Instead**: Use Batch Operation Pattern (2.4) with small commits

### 6.4 Avoid: Context Overload

**Problem**: Loading entire codebase into context

**Instead**: Use targeted searches and specific file sections

---

## Related

- `content/frameworks/autonomy/levels.md` — Autonomy level definitions
- `content/practices/ai_collaboration/` — AI collaboration best practices
- `.junie/guidelines.md` — Project collaboration guidelines
- `.history/` — Session history and handoffs

---

*Part of SAGE Knowledge Base - AI Intelligence Patterns*